\mode*

% Since this a solution template for a generic talk, very little can
% be said about how it should be structured. However, the talk length
% of between 15min and 45min and the theme suggest that you stick to
% the following rules:  

% - Exactly two or three sections (other than the summary).
% - At *most* three subsections per section.
% - Talk about 30s to 2min per frame. So there should be between about
%   15 and 30 frames, all told.


\section{Introduction}

\subsection{The idea and its origin}

\mode<all>{\includepdf[pages=42-47]{./dog-pubkey-tilkry24.pdf}}

%\subsection{Preliminaries}
%
%\mode<all>{\includepdf[pages=49-59]{./dog-pubkey-tilkry24.pdf}}

\section{Public-key cryptography}

\subsection{Key-exchange schemes}

\begin{frame}
  \begin{idea}
    \begin{itemize}
      \item It's difficult to have to exchange keys in advance.

        \pause{}

      \item What if we could securely exchange keys at a distance?
      \item If we could do it just before we use them?
    \end{itemize}
  \end{idea}

  \pause

  \begin{example}[Key agreement]
    \begin{itemize}
      \item Can exchange keys if set up properly.
      \item Kerberos is all about agreeing on symmetric keys---using only 
        symmetric keys.
    \end{itemize}
  \end{example}
\end{frame}



\begin{frame}
  \begin{solution}[Requirements]
    \begin{itemize}
      \item We need a problem that is easy for Alice and Bob.
      \item It should be hard for Eve.
    \end{itemize}
  \end{solution}
\end{frame}

%\mode<all>{\includepdf[pages=49-54]{./dog-pubkey-tilkry24.pdf}}

\begin{frame}
  \begin{definition}[\Acl{DLP}, \acs{DLP}]
    \begin{itemize}
      \item Let \(\ZZ_p^*\) be the multiplicative group of residues modulo 
        \(p\in \NN\), where \(p\) is a prime.

        \pause{}

        \begin{description}
          \item[Given] \(g, g^x\in \ZZ_p^*\)
          \item[Find] \(x\).
        \end{description}

      \item I.e.\ compute \(\log_{g\in \ZZ_p}(g^x)\).
    \end{itemize}
  \end{definition}
\end{frame}

\mode<all>{\includepdf[pages=59]{./dog-pubkey-tilkry24.pdf}}

\begin{frame}
  \begin{definition}[\Acl{DHP}, \acs{DHP}\footfullcite{DiffieHellman}]
    \begin{description}
      \item[Given] \(g, g^x, g^y\in \ZZ_p^*\)
      \item[Find] \(g^{xy}\)
    \end{description}
  \end{definition}

  \pause{}
  
  \begin{definition}[\Acl{DDH} Problem, \acs{DDH}]
    \begin{description}
      \item[Given] \(g, g^x, g^y, g^z\in \ZZ_p^*\)
      \item[Decide] \(z \stackrel{?}{=} xy\)
    \end{description}
  \end{definition}
\end{frame}

\begin{frame}
  \begin{itemize}
    \item If we can solve \ac{DLP}, then we can solve \ac{DHP} and \ac{DDH} 
      too.

      \pause{}

    \item Maybe \ac{DHP} and \ac{DDH} can be solved without \ac{DLP}.
    \item We don't know yet.

      \pause{}

    \item We usually assume \ac{DLP}, \ac{DHP} and \ac{DDH} are hard.
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{exercise}
    \begin{itemize}
      \item \citeauthor{DiffieHellman}\footfullcite{DiffieHellman} used 
        \ac{DHP} to create a key-exchange protocol.
        Take some time to think about how.
    \end{itemize}
  \end{exercise}

  \begin{block}{Reminder}
    \begin{itemize}
      \item Alice and Bob want to exchange a secret key.
      \item Then they can use the key to encrypt their communications.
    \end{itemize}
  \end{block}

  \begin{definition}[\Acl{DHP}, \acs{DHP}]
    \begin{description}
      \item[Given] \(g, g^x, g^y\in \ZZ_p^*\)
      \item[Find] \(g^{xy}\)
    \end{description}
  \end{definition}
\end{frame}

\begin{frame}
  \begin{definition}[Diffie-Hellman key-exchange]
    \begin{itemize}
      \item Let \(g\in \ZZ_p^*\) (publicly known, e.g.\ RFC, standard \dots).

        \pause{}

      \color{green!50!red}
      \item Alice generates random \(0 < x < |\ZZ_p^*|\).
      \item She sends \(g^x\) to Bob.

        \pause{}

      \color{blue}
      \item Bob generates random \(0 < y < |\ZZ_p^*|\).
      \item He sends \(g^y\) to Alice.

        \pause{}

      \color{green!50!red}
      \item Alice has \(x\) and \(g, g^y\).
      \color{blue}
      \item Bob has \(g, g^x\) and \(y\).
      \color{black}
      \item They both compute \(g^{xy} = {\color{green!50!red} (g^y)^x} 
          = {\color{blue} (g^x)^y}\).

        \pause{}

      \color{red}
      \item Eve has \(g, g^x, g^y\).
      \item By \ac{DHP} she cannot compute \(g^{xy}\).
    \end{itemize}
  \end{definition}
\end{frame}

\begin{frame}
  \begin{definition}[Diffie-Hellman key-exchange]
    \begin{itemize}
      \color{green!50!red}
      \item Alice has \(x\) and \(g, g^y\).

      \color{blue}
      \item Bob has \(g, g^x\) and \(y\).

      \color{black}
      \item They both compute \(g^{xy} = {\color{green!50!red} (g^y)^x} 
          = {\color{blue} (g^x)^y}\).

      \color{red}
      \item Eve has \(g, g^x, g^y\).
      \item By \ac{DHP} she cannot compute \(g^{xy}\).
    \end{itemize}
  \end{definition}

  \begin{onlyenv}<1>
  \begin{exercise}
    \begin{itemize}
      \item This is not secure as it is.
      \item Why?
    \end{itemize}
  \end{exercise}
  \end{onlyenv}

  \begin{onlyenv}<2>
  \begin{remark}[Man in the middle]
    \begin{itemize}
      \item This is not secure as it is.
      \item \(g^x, g^y\) are \emph{not authenticated}!
      \item Alice can't tell the difference between Bob and Eve!
    \end{itemize}
  \end{remark}
  \end{onlyenv}
\end{frame}

\section{Encryption and decryption}

\begin{frame}
  \begin{idea}
    \begin{itemize}
      \item Fine, we can use \(g^{xy}\) as a key in a cipher.
        \begin{itemize}
          \item \(\Enc[g^{xy}][m]\), where \(\Enc\) is a symmetric cipher.
        \end{itemize}
      \item But shouldn't we be able to include a message directly?
    \end{itemize}
  \end{idea}
\end{frame}

\begin{frame}
  \begin{definition}[ElGamal Encryption Scheme\footfullcite{ElGamal}]
    Set-up:
    \begin{itemize}
      \item Let \(g\in \ZZ_p^*\), randomly choose \(0 < x < |\ZZ_p^*|\).
      \item Alice publishes \(\ZZ_p^*, g, g^x\) to everyone.
    \end{itemize}
    Encryption:
    \begin{itemize}
      \item Bob chooses random \(0 < y < |\ZZ_p^*|\) and computes \(g^y\).
      \item Bob's message \(m\in \ZZ_p^*\).
      \item He sends \((g^y, m(g^{x})^y)\) to Alice.
    \end{itemize}
    Decryption:
    \begin{itemize}
      \item Alice computes \((g^y)^{-x}\) and \(m(g^x)^y (g^{y})^{-x} = m\).
    \end{itemize}
  \end{definition}
\end{frame}

\begin{frame}
  \begin{definition}[Chosen Plaintext Attack (CPA)]
    A \emph{chosen plaintext attack} is a scenario in which an adversary 
    can choose arbitrary plaintexts to be encrypted and then obtain the 
    corresponding ciphertexts.
  \end{definition}

  \pause{}

  \begin{example}
    \begin{itemize}
      \item Difficult for symmetric ciphers.
      \item Easy for public-key ciphers, just encrypt with the public key.
    \end{itemize}
  \end{example}
\end{frame}

\begin{frame}
  \begin{example}[CPA attack]
    \begin{itemize}
      \item Alice encrypts \(m\) with Bob's public key, gets \(c\).
      \item Alice sends \(c\) to Bob.
      \item Eve guesses \(m'\) might be the message.
      \item Eve encrypts \(m'\) with Bob's public key, gets \(c'\).
      \item If \(c = c'\), then \(m = m'\).
    \end{itemize}
  \end{example}

  \pause

  \begin{definition}[Semantic Security]
    An encryption scheme is \emph{semantically secure} if an adversary 
    cannot derive any meaningful information about the plaintext from the ciphertext.
  \end{definition}
\end{frame}


\begin{frame}
  \footnotesize
  \ltnote{%
    Variation pattern: contrast.
    We keep the game template invariant and vary only oracle access (CPA/CCA/CCA2)
    so students discern what extra power the adversary gets.
  }
  \begin{definition}[IND-CPA game]
    We define \ac{IND-CPA} security via the following game.
    \begin{description}
      \item[Setup] The challenger runs \(\Gen\), gives \(\pk\) to the adversary.
      \item[Queries] The adversary may query an encryption oracle 
        \(\Enc[_{\pk}][\cdot]\).
      \item[Challenge] The adversary submits equal-length \(m_0, m_1\).
        The challenger samples \(b \rgets \{0,1\}\) and returns
        \(c^\star \gets \Enc[_{\pk}][m_b]\).
      \item[Guess] The adversary outputs \(b'\).
        It wins if \(b' = b\).
    \end{description}
  \end{definition}
\end{frame}

\begin{frame}
  \footnotesize
  \begin{definition}[IND-CCA game (non-adaptive)]
    We define \ac{IND-CCA} security via the following game.
    \begin{description}
      \item[Setup] The challenger runs \(\Gen\), gives \(\pk\) to the adversary.
      \item[Queries] The adversary may query a decryption oracle 
        \(\Dec[_{\sk}][\cdot]\)
        before it chooses \(m_0, m_1\).
      \item[Challenge] The adversary submits equal-length \(m_0, m_1\).
        The challenger samples \(b \rgets \{0,1\}\) and returns
        \(c^\star \gets \Enc[_{\pk}][m_b]\).
      \item[Guess] The adversary outputs \(b'\).
        It wins if \(b' = b\).
    \end{description}
  \end{definition}

  \ltnote{%
    Critical aspect: access to \(\Dec\) can trivially break many PKE schemes.
    IND-CCA differs from IND-CPA only by adding the decryption oracle
    (here, only before the challenge).
  }
\end{frame}

\begin{frame}
  \footnotesize
  \begin{definition}[IND-CCA2 game (adaptive)]
    We define \ac{IND-CCA2} security via the following game.
    \begin{description}
      \item[Setup] The challenger runs \(\Gen\), gives \(\pk\) to the adversary.
      \item[Queries] The adversary may query a decryption oracle 
        \(\Dec[_{\sk}][\cdot]\)
        before and after receiving \(c^\star\).
      \item[Challenge] The adversary submits equal-length \(m_0, m_1\).
        The challenger samples \(b \rgets \{0,1\}\) and returns
        \(c^\star \gets \Enc[_{\pk}][m_b]\).
      \item[Restriction] The adversary may not query \(\Dec[_{\sk}][c^\star]\).
      \item[Guess] The adversary outputs \(b'\).
        It wins if \(b' = b\).
    \end{description}
  \end{definition}

  \ltnote{%
    The single additional rule (\enquote{do not decrypt the challenge ciphertext})
    prevents a trivial win while still capturing powerful adaptive attacks.
  }
\end{frame}

\begin{frame}
  \begin{definition}[ElGamal Encryption Scheme\footfullcite{ElGamal}]
    \footnotesize
    Set-up:
    \begin{itemize}
      \item Let \(g\in \ZZ_p^*\), randomly choose \(0 < x < |\ZZ_p^*|\).
      \item Alice publishes \(\ZZ_p^*, g, g^x\) to everyone.
    \end{itemize}
    Encryption and decryption:
    \begin{itemize}
      \item Bob chooses random \(0 < y < |\ZZ_p^*|\) and computes \(g^y\).
      \item Bob's message \(m\in \ZZ_p^*\).
      \item He sends \((g^y, m(g^{x})^y)\) to Alice.
      \item Alice computes \((g^y)^{-x}\) and \(m(g^x)^y (g^{y})^{-x} = m\).
    \end{itemize}
  \end{definition}

  \begin{onlyenv}<1>
  \begin{exercise}
    \begin{itemize}
      \item Why is ElGamal semantically secure under the \ac{DDH} assumption?
    \end{itemize}
  \end{exercise}
  \end{onlyenv}

  \begin{onlyenv}<2>
  \begin{remark}[Semantic Security of ElGamal]
    \begin{itemize}
      \item Because of that random \(y\)!
      \item And that \(y\) is \emph{different for each encryption}.
    \end{itemize}
  \end{remark}
  \end{onlyenv}
\end{frame}

\begin{frame}
  \begin{exercise}
    \begin{itemize}
      \item Is AES semantically secure?
    \end{itemize}
  \end{exercise}

  \begin{onlyenv}<2>
  \begin{remark}[Semantic Security of AES]
    \begin{itemize}
      \item Yes, with a proper block mode! Anything but ECB.
      \item The IV provides semantic security.
      \item \emph{New random} IV for \emph{every} encryption.
    \end{itemize}
  \end{remark}
  \end{onlyenv}
\end{frame}


\section{Digital signatures}

\begin{frame}
  \begin{idea}
    \begin{itemize}
      \item Sure, if Bob sends a message to Alice, he's sure she's the only one
        who can decrypt it.

        \pause{}

      \item Can't we turn this around?
        \begin{itemize}
          \item Can't Alice use the same system to ensure Bob knows the message
            came from Alice?
        \end{itemize}
    \end{itemize}
  \end{idea}
\end{frame}

\begin{frame}
  \begin{exercise}
    \begin{itemize}
      \item Look at the ElGamal encryption scheme for a bit.
      \item Try to find a way to \enquote{run it backwards}.
    \end{itemize}
  \end{exercise}

  \begin{definition}[ElGamal Encryption Scheme\footfullcite{ElGamal}]
    \footnotesize
    Set-up:
    \begin{itemize}
      \item Let \(g\in \ZZ_p^*\), randomly choose \(0 < x < |\ZZ_p^*|\).
      \item Alice publishes \(\ZZ_p^*, g, g^x\) to everyone.
    \end{itemize}
    Encryption and decryption:
    \begin{itemize}
      \item Bob chooses random \(0 < y < |\ZZ_p^*|\) and computes \(g^y\).
      \item Bob's message \(m\in \ZZ_p^*\).
      \item He sends \((g^y, m(g^{x})^y)\) to Alice.
      \item Alice computes \((g^y)^{-x}\) and \(m(g^x)^y (g^{y})^{-x} = m\).
    \end{itemize}
  \end{definition}
\end{frame}

\begin{frame}
  \footnotesize
  \begin{definition}[ElGamal Signature Scheme\footfullcite{ElGamal}]
    Set-up:
    \begin{itemize}
      \item Let \(g\in \ZZ_p^*\) and \framebox{\(h\) be a collision-reistant 
        hash function}.
      \item Alice publishes \(\ZZ_p^*, g, g^x\) to everyone.
    \end{itemize}
    Signing \(m\in \ZZ_p^*\):
    \begin{itemize}
      \item \framebox{Alice} chooses random \(0 < y < |\ZZ_p^*|\) and computes 
        \(r = g^y\in \ZZ_p^*\).
      \item She computes \framebox{\(s = (h(m) - xr) y^{-1} \pmod{|\ZZ_p^*|}\).}
      \item She sends \((r, s)\) to Bob.
    \end{itemize}
    Verification:
    \begin{itemize}
      \item \framebox{Bob checks if \(g^{h(m)} \stackrel{?}{=}_{\ZZ_p^*} (g^x)^r 
            r^s\)}\( =_{\ZZ_p^*}
          (g^x)^{g^y} (g^y)^{(h(m) - xg^y)y^{-1}} =_{\ZZ_p^*}
          g^{xg^y + h(m) - xg^y}\)
    \end{itemize}
  \end{definition}
\end{frame}

%\begin{frame}
%  \begin{block}{ElGamal encryption}
%    \begin{itemize}
%      \item \(\sk = x\), \(\pk = (g, g^x)\).
%      \item \((u,v) = \Enc[_{\pk}][y, m] = (g^y, m (g^x)^y)\)
%      \item \(\Dec[_{\sk}][u, v] = u^{-x} v = m\)
%    \end{itemize}
%  \end{block}
%
%  \begin{block}{ElGamal signatures}
%    \begin{itemize}
%      \item \(\sk = x\), \(\pk = (g, g^x)\).
%      \item \((r, s) = \Sign[_{\sk}][y, m] = (g^y, (h(m) - xg^y)y^{-1})\)
%      \item \(\Vrfy[_{\pk}][r, s, m] = g^{h(m)} \equiv (g^x)^r r^s\)
%    \end{itemize}
%  \end{block}
%\end{frame}

\begin{frame}
  \begin{remark}
    \begin{itemize}
      \item It works without the hash.
      \item But then we can multiply two messages and still get a valid 
        signature.
    \end{itemize}
  \end{remark}
\end{frame}

\section{Homomorphic properties}

\begin{frame}
  \begin{definition}[Homomorphism]
    A \emph{homomorphism} is a map (function) that preserves structure between 
    two algebraic structures.
  \end{definition}

  \pause{}

  \begin{example}
    \begin{itemize}
      \item Let \(G_1 = (\RR, \cdot)\) and \(G_2 = (\RR, +)\) be groups.
      \item \(g_1, g_1^\prime\in G_1\) and \(g_2, g_2^\prime\in G_2\).

        \pause{}

      \item Consider \(\log\colon G_1\to G_2\).
        
        \pause{}

      \item \(\log(g_1\cdot g_1^\prime) = g_2 + g_2^\prime\).
    \end{itemize}
  \end{example}
\end{frame}

\begin{frame}
  \begin{exercise}
    The encryption (decryption) function of the ElGamal cryptosystem is 
    a homomorphism, what structure does it preserve?
  \end{exercise}

  \begin{definition}[ElGamal Encryption Scheme\footfullcite{ElGamal}]
    \footnotesize
    Set-up:
    \begin{itemize}
      \item Let \(g\in \ZZ_p^*\), randomly choose \(0 < x < |\ZZ_p^*|\).
      \item Alice publishes \(\ZZ_p^*, g, g^x\) to everyone.
    \end{itemize}
    Encryption and decryption:
    \begin{itemize}
      \item Bob chooses random \(0 < y < |\ZZ_p^*|\) and computes \(g^y\).
      \item Bob's message \(m\in \ZZ_p^*\).
      \item He sends \((g^y, m(g^{x})^y)\) to Alice.
      \item Alice computes \((g^y)^{-x}\) and \(m(g^x)^y (g^{y})^{-x} = m\).
    \end{itemize}
  \end{definition}
\end{frame}

\begin{frame}
  \begin{example}[ElGamal's homomorphism]
    \begin{itemize}
      \item Messages \(m, m^\prime\), ciphertexts \((g^y, m\cdot g^{xy}), 
          (g^{y^\prime}, m^\prime\cdot g^{x y^\prime})\).

      \item Remember: private key \(x\), hence the same.

        \pause{}

      \item Create ciphertext (multiplying)
        \begin{align*}
          (g^y g^{y^\prime}, m\cdot g^{xy}\cdot m^\prime\cdot g^{x y^\prime})
          &= (g^{y + y^\prime}, m\cdot m^\prime\cdot g^{xy + xy^\prime}) \\
          &= (g^{y + y^\prime}, m\cdot m^\prime\cdot g^{x(y + y^\prime)}).
        \end{align*}

        \pause{}

      \item Decryption: take \(g^{y + y^\prime}\), compute \((g^{y+y^\prime})^x 
          = g^{x(y + y^\prime)}\).

      \item Decryption thus yields \(m\cdot m^\prime\).

    \end{itemize}
  \end{example}
\end{frame}

\begin{frame}
  \begin{remark}[Digital signatures]
    \begin{itemize}
      \item We use a hash function in the signature scheme to counter the 
        homomorphic property.

      \item \(h(m)\cdot h(m^\prime)\neq h(m\cdot m^\prime)\).

        \pause{}

      \item Without the hash function we could create a valid signature for 
        a new message \emph{without knowing the signature key!}
    \end{itemize}
  \end{remark}

  \pause

  \begin{exercise}[Public-key encryption]
    \begin{itemize}
      \item How to deal with encryption and decryption?
    \end{itemize}
  \end{exercise}
\end{frame}

\begin{frame}[fragile]
  \begin{solution}
    \begin{itemize}
      \item Padding!
      \item See e.g.~OAEP+.
      \item And see the Public Key Cryptography Standards (PKCS).
    \end{itemize}
  \end{solution}

  \begin{example}[OAEP+]
    \begin{itemize}
      \item Standardized in PKCS\#1 v2 and RFC 2437.
    \end{itemize}
  \end{example}

  \begin{example}[\Ac{DH} key-agreement]
    \begin{itemize}
      \item Standardized in PKCS\#3, v1.4.
    \end{itemize}
  \end{example}
\end{frame}

\begin{frame}
  \begin{remark}
    \begin{itemize}
      \item There are many schemes with different homomorphic properties.
      \item There is even \emph{fully homomorphic 
        encryption}~\footfullcite{GentryFullyHomomorphicEncryption}.
    \end{itemize}
  \end{remark}
\end{frame}


\section{Key management}

\subsection{Symmetric key distribution}

\begin{frame}
  \begin{itemize}
    \item Deliver a key \(k\) from \(A\) to \(B\).
      By themselves or third party.

    \item If \(A\) and \(B\) share a key \(k\), generate a key \(k^\prime\) and 
      transmit it using \(k\):
      \(A\to B\colon E_k(k^\prime)\).

    \item Secure connection to third party \(C\), \(C\) delivers key to \(A\) 
      and \(B\).

  \end{itemize}
\end{frame}

\begin{frame}
  \begin{description}
    \item[Session Key] Temporary key used between \(A\) and \(B\).

    \item[Permanent Key] Key used to distribute session keys.

    \item[Key Distribution Centre] The central entity with which permanent keys 
      are shared and by whom session keys are generated.

  \end{description}
\end{frame}


%\begin{frame}
%  \footnotesize
%  \begin{example}[Kerberos (symmetric key distribution)]
%    \centering
%    \begin{tikzpicture}[x=1cm,y=1cm,>=stealth,thick]
%      \node (C) at (0,0) {Client};
%      \node (K) at (5,0) {KDC (AS+TGS)};
%      \node (S) at (10,0) {Server};
%
%      \draw (C) ++(0,-0.2) -- ++(0,-4.4);
%      \draw (K) ++(0,-0.2) -- ++(0,-4.4);
%      \draw (S) ++(0,-0.2) -- ++(0,-4.4);
%
%      \draw[->] (0,-0.8) -- node[above,align=center]{1.~AS-REQ} (5,-0.8);
%      \draw[<-] (0,-1.3) -- node[below,align=center]{2.~AS-REP: TGT + $K_{C,TGS}$} (5,-1.3);
%
%      \draw[->] (0,-2.1) -- node[above,align=center]{3.~TGS-REQ (TGT, $S$)} (5,-2.1);
%      \draw[<-] (0,-2.6) -- node[below,align=center]{4.~TGS-REP: ticket$_S$ + $K_{C,S}$} (5,-2.6);
%
%      \draw[->] (0,-3.4) -- node[above,align=center]{5.~AP-REQ: ticket$_S$ + authenticator} (10,-3.4);
%      \draw[<-] (0,-3.9) -- node[below,align=center]{6.~AP-REP (optional)} (10,-3.9);
%    \end{tikzpicture}
%
%    \vspace{0.5em}
%
%    Kerberos relies on a trusted KDC and symmetric long-term keys; PKI replaces this
%    central online key-distribution step with certificates.
%  \end{example}
%\end{frame}
%
\begin{frame}
  \footnotesize
  \begin{example}[Kerberos IV (single KDC): Alice gets a ticket for Bob]
    Long-term keys: Alice shares \(\kA\) with the KDC; Bob shares \(\kB\) with the KDC.

    \vspace{0.3em}

    To bind secrecy and integrity, we use encrypt-then-\ac{MAC} (\ac{EtM}):
    \[
      c := \Enc[_{K}][m]
      \qquad\text{and}\qquad
      \tau := \Mac[_{K}][c].
    \]

    \vspace{0.3em}

    \(A\to\text{KDC}:\ A,\ B,\ n_A\). The KDC samples a fresh session key \(\kAB\) and
    creates a ticket for Bob:
    \[
      \text{ticket}_B := \Enc[_{\kB}][\,A,\ B,\ \kAB,\ \text{lifetime},\ \text{flags}]
      \qquad\text{and}\qquad
      \tau_B := \Mac[_{\kB}][\text{ticket}_B].
    \]
    The KDC replies to Alice under \(\kA\):
    \[
      c_A := \Enc[_{\kA}][\,\kAB,\ \text{lifetime},\ \text{ticket}_B,\ \tau_B,\ n_A]
      \qquad\text{and}\qquad
      \tau_A := \Mac[_{\kA}][c_A].
    \]
  \end{example}
\end{frame}

\begin{frame}
  \footnotesize
  \begin{example}[Kerberos IV (single KDC): Alice authenticates to Bob]
    Alice sends Bob the ticket plus an authenticator proving freshness:
    \[
      \text{auth} := \Enc[_{\kAB}][\,A,\ t_A,\ \text{seq}]
      \qquad\text{and}\qquad
      \sigma := \Mac[_{\kAB}][\text{auth}].
    \]
    \(A\to B:\ \text{ticket}_B,\ \tau_B,\ \text{auth},\ \sigma\).

    \vspace{0.4em}

    Bob verifies the protocol by checking that the crypto pieces bind together:
    \begin{itemize}
      \item Verify \(\tau_B\) with \(\kB\), then decrypt \(\text{ticket}_B\) with \(\kB\)
        to recover \(\kAB\), the claimed client \(A\), the intended server \(B\), and
        the ticket lifetime.
      \item Check the ticket is meant for Bob and still valid (lifetime/flags).
      \item Verify \(\sigma\) with \(\kAB\), decrypt \(\text{auth}\), and check:
        \(A\) matches the ticket and \(t_A\) is within a small clock-skew window
        (and not previously seen).
    \end{itemize}

    Optional mutual authentication: \(B\to A:\ \Enc[_{\kAB}][t_A+1]\) (plus a \ac{MAC}).
  \end{example}
\end{frame}

\begin{frame}
  \footnotesize
  \begin{example}[Kerberos IV (single KDC): simplified dialogue]
    \centering
    \begin{tikzpicture}[x=1cm,y=1cm,>=stealth,thick]
      \node (A) at (0,0) {Alice};
      \node (K) at (5,0) {KDC};
      \node (B) at (10,0) {Bob};

      \draw (A) ++(0,-0.2) -- ++(0,-3.2);
      \draw (K) ++(0,-0.2) -- ++(0,-3.2);
      \draw (B) ++(0,-0.2) -- ++(0,-3.2);

      \draw[->] (0,-0.8) -- node[above,align=center]{1.~$A, B, n_A$} (5,-0.8);
      \draw[<-] (0,-1.5) -- node[below,align=center]{2.~$c_A, \tau_A$\\$c_A=\Enc[_{\kA}][\kAB, \text{ticket}_B, n_A]$\\$\text{ticket}_B=\Enc[_{\kB}][A,B,\kAB,\text{lifetime}]$\\$\tau_A=\Mac[_{\kA}][c_A], \tau_B=\Mac[_{\kB}][\text{ticket}_B]$} (5,-1.5);
      \draw[->] (0,-2.4) -- node[above,align=center]{3.~$\text{ticket}_B, \tau_B, \text{auth}, \sigma$\\$\text{auth}=\Enc[_{\kAB}][A,t_A,\text{seq}], \sigma=\Mac[_{\kAB}][\text{auth}]$} (10,-2.4);
    \end{tikzpicture}
  \end{example}
\end{frame}

\begin{frame}
  \footnotesize
  \begin{example}[Kerberos keys (derived, not reused)]
    In the slides we wrote \(\Enc[_{K}][\cdot]\) and \(\Mac[_{K}][\cdot]\) using the
    same key \(K\) to highlight how fields are bound together.

    \vspace{0.4em}

    In real Kerberos, the encryption key and the integrity/checksum key are
    typically derived from a shared base key using a \textsf{KDF} (and a
    \emph{key-usage} label to separate contexts):
    \[
      K^{\text{enc}} := \KDF[_{K}][\text{enc} \concat \text{usage}]
      \qquad\text{and}\qquad
      K^{\text{mac}} := \KDF[_{K}][\text{mac} \concat \text{usage}].
    \]
    Then the protocol uses \(\Enc[_{K^{\text{enc}}}][\cdot]\) and
    \(\Mac[_{K^{\text{mac}}}][\cdot]\), but the binding idea stays the same.
  \end{example}
\end{frame}

\begin{frame}
  \footnotesize
  \begin{example}[Kerberos V (generalization)]
    Same bindings as Kerberos IV, but the KDC is split into an authentication
    server (AS) and a ticket-granting server (TGS):
    \begin{itemize}
      \item First obtain a ticket-granting ticket (TGT) and a key \(K_{A,\text{TGS}}\)
        protected under the client--AS long-term key.
      \item Then use the TGT to obtain a service ticket \(\text{ticket}_B\) and the
        session key \(\kAB\) protected for Bob.
      \item The client-to-server step stays the same: send \(\text{ticket}_B\) plus an
        authenticator containing a timestamp, protected under \(\kAB\).
    \end{itemize}
  \end{example}
\end{frame}

\subsection{Public-key infrastructures}

\mode<all>{\includepdf[pages=96-99]{./dog-pubkey-tilkry24.pdf}}

\begin{frame}
  \begin{example}[Certificate validation is more than signatures]
    When Bob receives Alice's certificate, he must do \emph{all} of:
    \begin{itemize}
      \item Verify the signature chain up to a trusted root (\ac{PKI}).
      \item Check the certificate validity interval (not-before / not-after).
      \item Check the certificate is \emph{not revoked}.
    \end{itemize}
    Signature verification alone only says \enquote{this CA once issued this cert},
    not \enquote{it is still acceptable to use today}.
  \end{example}
\end{frame}

\begin{frame}
  \footnotesize
  \begin{example}[Revocation lists (CRLs)]
    A certificate revocation list (\textsf{CRL}) is a CA-signed list of certificate
    identifiers (typically serial numbers) that must be rejected.

    \vspace{0.4em}

    Validation with a \textsf{CRL}:
    \begin{itemize}
      \item Fetch the issuer's current \textsf{CRL} (via the CRL distribution point).
      \item Verify the \textsf{CRL} signature using the issuer's public key.
      \item Check the \textsf{CRL} is fresh enough (thisUpdate/nextUpdate).
      \item Reject the certificate if its serial number appears in the \textsf{CRL}.
    \end{itemize}
  \end{example}
\end{frame}

\begin{frame}
  \footnotesize
  \begin{example}[Online revocation checks (OCSP)]
    Instead of downloading full \textsf{CRLs}, a client can query an online status
    service (\textsf{OCSP}):
    \begin{itemize}
      \item Client asks: \enquote{Is cert serial \#X revoked?}
      \item Responder returns a signed status: \enquote{good / revoked / unknown}.
      \item Client checks responder signature and freshness.
    \end{itemize}
    This makes revocation a required step \emph{before} accepting a certificate for
    authentication or key establishment.
  \end{example}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[allowframebreaks]
  \printbibliography
\end{frame}
