\mode*

\section[Hash functions]{What was a hash function now again?}

\begin{frame}
  \begin{definition}[One-way function\footfullcite{GoldreichFOC-1}]
    \begin{itemize}
      \item Let \(h\colon \{0,1\}^*\to \{0,1\}^*\).
      \item \(h\) is \emph{one-way} if
        \begin{enumerate}
          \item there exists an efficient algorithm \(A\) such that \(A(x) 
              = h(x)\);
          \item for every efficient algorithm \(A^\prime\), every positive 
            polynomial \(p(\cdot)\) and all sufficiently large \(n\)'s
            \[\Prob{A^\prime(h(x), 1^n) \in h^{-1}(h(x))} < \frac{1}{p(n)}\]
        \end{enumerate}
    \end{itemize}
  \end{definition}
\end{frame}

\begin{frame}
  \begin{definition}[Preimage resistance (one way)]
    \begin{description}
      \item[Input] hash function~\(H\), value~\(y\).
      \item[Output] Any \(x\) such that \(H(x) = y\).
    \end{description}
  \end{definition}

  \begin{definition}[Second preimage resistance (weak collision resistance)]
    \begin{description}
      \item[Input] hash function~\(H\), value \(x\).
      \item[Output] Any value \(x'\) such that \(H(x) = H(x')\).
    \end{description}
  \end{definition}

  \begin{definition}[Collision resistance (strong collision resistance)]
    \begin{description}
      \item[Input] hash function~\(H\).
      \item[Output] Any two \(x, x'\) such that \(H(x) = H(x')\).
    \end{description}
  \end{definition}
\end{frame}


\section{Commitments}

\begin{frame}
  \begin{example}[Guess a number]
    \begin{itemize}
      \item Eve chooses a secret number/message \(m\).
      \item Alice will guess \(m\).
      \item Eve must \emph{commit} to \(m\) before Alice starts guessing.
      \item Eve will try to cheat if she can.
    \end{itemize}
  \end{example}

  \begin{exercise}[Try first]
    Design a protocol.

    \begin{description}
      \item[Hiding] Alice should not learn \(m\) from the first message.
      \item[Binding] Eve should not be able to change \(m\) after Alice starts
        guessing.
    \end{description}

    What could Eve send before the game starts?
  \end{exercise}

  \ltnote{%
    \textbf{Try-first--tell-later}: We start with a concrete two-party fairness
    problem.

    \textbf{Critical aspects}: two different goals (hiding vs binding).

    \textbf{Variation pattern}: Generalization.
  }
\end{frame}

\begin{frame}
  \begin{block}{Hash functions and \acp{MAC}}
    \begin{itemize}
      \item Both take a long input and output a short string.
      \item We will use them to \emph{lock in} a value now and \emph{reveal} it
        later.
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}
  \begin{block}{Solution attempt 1: hash only (no randomness)}
    Eve sends \(c = \Hash[m]\).

    Later, Eve reveals \(m\) and Alice checks \(\Hash[m] \stackrel?= c\).
  \end{block}
\end{frame}

\begin{frame}
  \begin{description}
    \item[Binding] looks plausible (needs collision resistance).
    \item[Hiding] fails if \(m\) is guessable (brute force).
  \end{description}
\end{frame}

\begin{frame}
  \begin{block}{Solution attempt 2: hash + randomness}
    Eve samples fresh randomness \(r\) and sends
    \[c = \Hash[\Encode(r,m)].\]

    Later, Eve reveals \((m,r)\). Alice checks
    \(\Hash[\Encode(r,m)] \stackrel?= c\).
  \end{block}
\end{frame}

\begin{frame}
  \begin{description}
    \item[Binding] still relates to collision resistance.
    \item[Hiding] improves if \(r\) has high entropy.
  \end{description}

  \ltnote{%
    \textbf{Variation pattern}: Contrast.

    We vary one critical aspect: add randomness \(r\). The protocol structure is
    otherwise invariant.
  }
\end{frame}

\begin{frame}
  \begin{block}{Solution attempt 3: \ac{MAC} with one-time key}
    Eve samples fresh randomness \(r\) and sends the tag
    \[t = \Mac[r][m].\]

    Later, Eve reveals \((m,r)\). Alice checks \(\Mac[r][m] \stackrel?= t\).
  \end{block}
\end{frame}

\begin{frame}
  \begin{description}
    \item[Hiding] Alice cannot test guesses without knowing \(r\).
    \item[Binding] Eve cannot easily find \(m'\neq m\) with the same tag.
  \end{description}
\end{frame}

\begin{frame}
  \begin{definition}[Commitment scheme]
    A commitment scheme has two algorithms:
    \begin{description}
      \item[\Commit] take a message \(m\), output a commitment \(c\).
      \item[\Open] reveal information that convinces the verifier that \(c\)
        corresponds to \(m\).
    \end{description}
  \end{definition}

  \begin{definition}[Security goals]
    \begin{description}
      \item[Hiding] seeing \(c\) should not reveal \(m\).
      \item[Binding] after seeing \(c\), it should be hard to open it to a
        different message \(m'\neq m\).
    \end{description}
  \end{definition}
\end{frame}

\begin{frame}
  \begin{block}{Hiding vs binding: extremes}
    \begin{description}
      \item[Perfectly binding, not hiding] send \(m\) directly.
      \item[Perfectly hiding, not binding] send a random \(c\) independent of
        \(m\).
    \end{description}

    A useful commitment needs \emph{both}: hiding for the guesser and binding for
    fairness.
  \end{block}

  \ltnote{%
    \textbf{Variation pattern}: Contrast.

    We contrast the two extreme failure modes to make the tension between the
    goals visible.
  }
\end{frame}

\begin{frame}
  \begin{remark}[Comparison: OTP and perfect secrecy]
    \begin{description}
      \item[OTP] perfectly hiding: \(c = m \oplus k\) with fresh random key \(k\).
      \item[Commitment] must be both hiding and binding.
    \end{description}

    The OTP achieves perfect secrecy because the ciphertext distribution is
    independent of \(m\). By contrast, a commitment cannot be independent of
    \(m\), otherwise it would not bind.
  \end{remark}
\end{frame}

\begin{frame}
  \begin{exercise}
    In the hash-based constructions, which hash property relates most to binding?
  \end{exercise}
\end{frame}

\begin{frame}
  \begin{remark}[Intuition: why the properties hold]
    \begin{description}
      \item[Binding] If Alice can open \(c\) as \((m, r)\) and also as
        \((m', r')\) with \(m\neq m'\), then she found a collision:
        \(\Hash[\Encode(r,m)] = \Hash[\Encode(r',m')]\).
      \item[Hiding] If \(r\) is fresh and unpredictable, then \(c\) does not
        reveal \(m\) (informally: it looks like a random hash output).
    \end{description}
  \end{remark}

  \ltnote{%
    \textbf{Variation pattern}: Fusion

    Here we tie together two critical aspects at the same time:
    (1) collision resistance \(\Rightarrow\) binding, and
    (2) randomness/entropy \(\Rightarrow\) hiding.

    Students need both in view simultaneously to reason about who can cheat and
    how.
  }
\end{frame}

\begin{frame}
  \begin{example}[Coin flipping over the network]
    \begin{enumerate}
      \item Alice chooses a random bit \(a\) and randomness \(r\).
        She sends \(c = \Hash[\Encode(r,a)]\).
      \item Bob chooses a random bit \(b\) and sends \(b\).
      \item Alice opens by sending \((a, r)\). Result is \(a\oplus b\).
    \end{enumerate}
  \end{example}

  \begin{exercise}
    Who could cheat if (1) hiding failed? (2) binding failed?
  \end{exercise}

  \ltnote{%
    \textbf{Variation pattern}: Contrast

    We contrast two failure modes: \enquote{hiding fails} vs \enquote{binding
    fails}. Invariant: the same protocol.

    This makes it clear that the two security goals benefit different parties.
  }
\end{frame}

\begin{frame}
  \begin{exercise}[Try first]
    Alice commits to \((r,m)\) by sending the string
    \(\Encode(r)\concat\Encode(m)\).

    \begin{itemize}
      \item What could go wrong if \(\Encode\) is just
        \enquote{write the bits with no delimiter and no length}?
      \item Can you find two different pairs \((r,m)\neq(r',m')\) that yield the
        same concatenation?
    \end{itemize}
  \end{exercise}
\end{frame}

\begin{frame}
  \begin{remark}[Encoding must be unambiguous]
    Two common fixes:
    \begin{description}
      \item[Length-prefix] Encode as
        \(\Encode(r,m)=\langle |r|,r,m\rangle\) (store the bit-length of \(r\) first).
      \item[Structured format] Use a canonical serialization (e.g., CBOR/ASN.1/
        Protocol Buffers) with domain separation.
    \end{description}

    In practice, prefer a standard commitment/serialization rather than inventing
    one.
  \end{remark}
\end{frame}

\begin{frame}
  \begin{remark}[Pitfalls and good practice]
    \begin{itemize}
      \item Use fresh randomness \(r\) for every commitment.
      \item Ensure \(r\) has enough entropy (think: at least 128 bits).
      \item Use an unambiguous encoding of \((r, m)\) before hashing.
      \item Avoid ad-hoc constructions in real systems; use standard schemes.
    \end{itemize}
  \end{remark}

  \ltnote{%
    \textbf{Design note}: This stays at the level of \enquote{practical red
    flags}, not a fully formal treatment.

    For an applied crypto course it is enough that students can recognize when a
    commitment is obviously unsafe (low entropy, reusing randomness, ambiguous
    serialization).
  }
\end{frame}

\section{Keyed hash functions}

\begin{frame}
  \begin{block}{How this relates to \ac{HMAC}}
    \begin{description}
      \item[\ac{HMAC}] integrity/authenticity with a shared secret key \(k\).
      \item[Commitment] use public verification: anyone can check an opening.
    \end{description}
  \end{block}


  \ltnote{%
    \textbf{Variation pattern}: Contrast.

    Students compare \enquote{shared secret key} (HMAC) with \enquote{randomness
    revealed later} (commitment).
  }
\end{frame}

\begin{frame}
  \begin{exercise}
    If you \emph{did} share a secret key with the verifier, would you still need
    randomness \(r\) to hide the message?
  \end{exercise}
\end{frame}

\begin{frame}
  \begin{remark}[Take-away]
    \begin{itemize}
      \item Commitments are \emph{not} encryption and \emph{not} MACs.
      \item Hash-based commitments are simple:
        \(c = \Hash[\Encode(r,m)]\) with an unambiguous encoding.
      \item Binding \(\approx\) collision resistance; hiding \(\approx\)
        high-entropy randomness \(r\).
    \end{itemize}
  \end{remark}
\end{frame}

