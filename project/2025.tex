\chapter{Police body cams}\label{PoliceCamStatement}
\chapterprecis{%
  This chapter is from DD2520 Applied Crypto, spring 2025, at KTH\@.
}

Law enforcement agencies increasingly rely on body-worn cameras to log 
interactions with the public.
With concerns over tampering, withholding of critical parts or realistic fake 
footage, there is a need to cryptographically verify the authenticity of these 
recordings.
(Note that this is a completely fictitious scenario.)

These videos are also strictly confidential, due to many people's privacy is 
violated (whoever is captured in the videos).
The video material is only partially released as evidence in a trial after 
review.

Only a special joint group within the police and the attorney's office can 
access, review and share parts of the video material.
The material can be used as evidence in court, both in ordinary criminal cases 
and in cases of police misconduct.

\begin{exercise}
  Think about how you would design a system using cryptographic primitives to 
  ensure the confidentiality, integrity, authenticity and availability of the 
  video material.
\end{exercise}

\ltnote{%
  The idea is to create the simplest solution possible.
  Then we will focus one aspect at a time by making one small change to the 
  solution at a time.
  This will introduce the contrast necessary to bring the aspect into 
  focus \parencite[as dictated by][]{NecessaryConditionsOfLearning}.
  We will do this until we have touched on all aspects and arrived at the 
  perfect solution.
  (One could also think of this as a sequence of games, as used in cryptography 
  \parencite{Shoup2004Sequences}.
  Arguably, the reason why the sequences of games method by 
  \citeauthor{Shoup2004Sequences} is good for humans is explained by 
  \citeauthor{NecessaryConditionsOfLearning}.)
}
\section{A first solution}

Now we'll start with a first solution to the problem.
We see in \cref{PoliceCamStatement} that we have a few entities that we're 
interested in:
\begin{itemize}
  \item the police officer~\(P\) that wears the camera,
  \item the camera~\(C\) that records the video,
  \item the reviewers~\(R\) who check the video material,
  \item the court that uses the video material as evidence.
\end{itemize}

\begin{exercise}
  What is the goal of the system, in terms of these entities?
\end{exercise}

The goal is that the camera~\(C\) captures the context of the police 
officer~\(P\) so that the reviewers~\(R\) can filter them out and supply the 
court with evidence.

\begin{exercise}
  Design the cryptographic system that ensures the confidentiality, integrity 
  and authenticity of the video material as it is captured and transferred 
  between these entities.
\end{exercise}

The simplest design is to use a shared symmetric key between the camera~\(C\) 
and the reviewers~\(R\).
The police officer~\(P\) doesn't need access and doesn't need to be involved 
more than wearing the camera and returning it to the police station.
That's both more secure and more usable.

With that shared key, the camera~\(C\) can encrypt (confidentiality) and MAC 
(integrity and authentication) the video material as it is captured.

\subsection{Managing the keys}

\NewVariable{\KCR}{K_{CR}}

We have a shared symmetric key~\(\KCR\) between the camera~\(C\) and the 
reviewers~\(R\).
(This means that we need one such key for each camera.)

\begin{exercise}
  How should these keys be stored?
\end{exercise}

This key must be stored in a secure way in each camera.
We can use some form of secure element to store the key, \eg a TPM (Trusted 
Platform Module) or an HSM (Hardware Security Module) or a smart card (think 
SIM card).

We let the reviewers~\(R\) be represented by a server.
The server is much more physically secure and must store many more keys,
so the keys can be stored in a database on the server.
However, we can make this an encrypted database and the key to the database is 
stored in a secure element.

Whenever a reviewer in \(R\) needs to access the database, they must 
authenticate themselves to the server which then decrypts the key~\(\KCR\) to 
decrypt the video material by camera~\(C\).

\subsection{Encrypting video for \(R\)}

\NewAlgorithm{\Enc}{Enc}
\NewAlgorithm{\Dec}{Dec}
\NewAlgorithm{\KDF}{KDF}
\NewVariable{\KENC}{K_{CR}^{\Enc}}

We will use AES to do encryption.

\begin{exercise}
  How exactly should we do this encryption?
  The entire video (many megabytes, even gigabytes) will not fit into one block 
  of AES (128 bits).
\end{exercise}

We can see in \cref{fig:EncModes} that it is very important to pick a good mode 
of operation in this context (videos).
We will use GCM (Galois/Counter Mode) to get authenticated encryption.
This mode has a built-in MAC.
We will need a random IV (initialization vector).
We can use a key-derivation function to derive the encryption key from 
\(\KCR\):
\begin{align*}
  \KENC &= \KDF[\Enc, \KCR]. \\
  \intertext{For \(m = m_1, m_2, \ldots, m_n\), we let}
  c &= \Enc[\KENC, m]
  \text{ denote the encryption of message~\(m\) under key \(\KENC\).}\\
  m &= \Dec[\KENC, c]
  \text{ is the decryption.}
  \intertext{However, what happens under the hood is that}
  c &= c_1, c_2, \ldots, c_n, t \text{ where each} \\
  c_i &\text{ depends on \(m_i\) and \(c_{i-1}\) in line with GCM,} \\
  t &\text{ is the built-in MAC tag.}
\end{align*}
The decryption fails if the built-in MAC is invalid---that is, \(c_i\) has been 
tampered with.
Tampered with, in this context, includes bit modifications and that someone has 
dropped a few bits the entire block.
Running the decryption on \(c' = c_1, c_3, \ldots, c_n,\) will fail.

\begin{figure}
  \begin{sidecaption}[Tux encrypted using different modes.]{%
    Tux encrypted using different block modes of operation.
    When using ECB mode (\cref{fig:EncModes:TuxECB}), we can still distinguish 
    Tux.
    But we expect encryption to have the effect as shown in 
    \cref{fig:EncModes:TuxCTR}.
  }[fig:EncModes]
  \hfill
  \begin{subfigure}[t]{0.3\linewidth}
    \includegraphics[width=\linewidth]{figs/Tux.pdf}
    \caption{Original Tux.
    Image by: Larry Ewing, Simon Budig, Garrett LeSage.}
    \label{fig:EncModes:Tux}
  \end{subfigure}
  \hfill
  \begin{subfigure}[t]{0.3\linewidth}
    \includegraphics[width=\linewidth]{figs/Tux_encrypted_ecb.png}
    \caption{ECB-encrypted Tux.
    Image by: RFL890.}
    \label{fig:EncModes:TuxECB}
  \end{subfigure}
  \hfill
  \begin{subfigure}[t]{0.3\linewidth}
    \includegraphics[width=\linewidth]{figs/Tux_encrypted_ctr.png}
    \caption{CTR-encrypted Tux.
    Image by: RFL890.}
    \label{fig:EncModes:TuxCTR}
  \end{subfigure}
  \hspace{\fill}
  \end{sidecaption}
\end{figure}

\NewVariable{\IV}{IV}

We can initialize the camera with the key~\(\KCR\) and the IV~\(\IV\).
Now the camera needs no own source of randomness.
That simplifies the camera's design and makes it cheaper to produce.

We need to rotate the keys in all the cameras.
We'll have to do that by hand.
Whenever we replace a key, we also replace the IV\@.
However, an alternative would be to use a key-derivation function to derive the 
next key:
\begin{align*}
  K_{CR}^{(i+1)} &= \KDF[\text{next key}, K_{CR}^{(i)}]. \\
  \IV_{i+1} &= \KDF[\text{next IV}, \IV_i].
\end{align*}

\subsection{Uploading data to \(R\)}

When the police officer~\(P\) returns to the station with the camera~\(C\), the 
camera is connected to a docking station.
Then it automatically uploads all the video material to the reviewers~\(R\) and 
removes it from its own memory.
See \cref{fig:TransferCR} for the protocol.

\begin{figure}
  \begin{sidecaption}[Transfer data from \(C\) to \(R\).]{%
    The camera~\(C\) uploads video material to the reviewers~\(R\).
    It first encrypts the video \(m\) as it is captured.
    So that it stores only \(c\).
    It identifies as \(C\) so that that \(R\) knows where the video material 
    comes from, but more importantly so that \(R\) knows which key to use 
    (\(\KCR\)).
    Once the encrypted video material \(c\) is uploaded, the reviewers can 
    decrypt it.
    Due to authenticated encryption, any modifications will be detected.
    And \(R\) will know that the material was produced by \(C\).
    The camera then drops the video material to free space.
  }[fig:TransferCR]
  \flushright
  \begin{msc}
    [/msc/action width=0.4\linewidth]
    {Transfer data from \(C\) to \(R\)}
      \declinst{cam}{Camera \(C\)}{\(\KCR\)}
      \declinst{rev}{Reviewers \(R\)}{\(\KCR\)}
      \mscaction{\(c = \Enc[\KENC, m]\)}{cam}
      %\mscaction{$c = \Enc[\KENC, m]$}{cam}
      \nextlevel[4]
      \mess{I'm camera \(C\).}{cam}{rev}
      \nextlevel[2]
      \mess{Upload video material \(c\).}{cam}{rev}
      \nextlevel
      \mscaction{\(m = \Dec[\KENC, c]\)}{rev}
      \mscaction{Drop \(c\)}{cam}
      \nextlevel
  \end{msc}
  \end{sidecaption}
\end{figure}

\subsection{Consequences of the design}

The design has a few consequences:
\begin{enumerate}
  \item The camera~\(C\) needs no own source of randomness.
    This makes it cheaper to manufacture.
  \item A corrupt police officer~\(P\) can trick the camera to drop video 
    material.
    If the camera believes that it has uploaded the video material, it will 
    drop it.
    However, the reviewers~\(R\) will notice that the video material is missing 
    because the IV and key will be out of sync.
  \item The courts must trust the reviewers~\(R\) to have the correct video 
    material.
    The reviewers~\(R\) can tamper with the video material.
    The reviewers~\(R\) can also withhold video material.
\end{enumerate}


\section{Manually dealing with integrity}

Now we will use CTR mode (instead of GCM) and use HMAC separately to ensure 
integrity.
We will use CTR (counter) mode as this mode is light-weight and highly 
parallellizable (same benefit as in GCM).
This requires a random IV (initialization vector) in addition to the key, same 
as for GCM\@.

Similarly to above, we let
\begin{align*}
  c &= \Enc[\KENC, m]\text{, where} \\
  c &= c_1, c_2, \ldots, c_n \text{, and} \\
  c_i &= c_i' \oplus m_i \text{ for each block of plaintext \(m_i\) and} \\
  c_i' &= \Enc[\KENC, \IV \concat i] \text{ is the encryption of the counter}.
\end{align*}

\NewAlgorithm{\MAC}{HMAC}
\NewVariable{\KMAC}{K_{CR}^{\MAC}}

We also need to ensure integrity.
We will use HMAC-SHA256 for this.
We use another key-derivation function to derive the HMAC key from \(\KCR\):
\begin{align*}
  \KMAC &= \KDF[\MAC, \KCR].
\end{align*}
We will compute a MAC value for every minute of video material (ciphertext).
Say that we have \(N\) blocks of ciphertext for every minute of video material.
That MAC value contains the previous MAC and the current section of ciphertext 
blocks (\(N\) blocks).
\begin{align*}
  t_0 &= \MAC[\KMAC, c_0, \ldots, c_{N-1}] \text{ and} \\
  t_i &= \MAC[\KMAC, t_{i-1}, c_{i\cdot N}, \ldots, c_{(i+1)\cdot N-1}]
  \text{ for all \(i\geq 1\)}.
\end{align*}
This way, if something interrupts the camera, we have everything MACed properly 
on a regular basis.

This gives us the protocol in \cref{fig:TransferCRHMAC}.

\begin{figure}
  \begin{sidecaption}[Transfer data from \(C\) to \(R\) using HMAC]
    {%
      The camera~\(C\) uploads video material to the reviewers~\(R\).
      It first encrypts the video \(m = m_0, \ldots, m_n\) as it is captured.
      So that it stores only \(c = c_0, \ldots, c_{N-1}, t1, c_{N}, \ldots\).
      It identifies as \(C\) so that that \(R\) knows where the video material 
      comes from, but more importantly so that \(R\) knows which key to use 
      (\(\KCR\)).
      Once the encrypted video material \(c\) is uploaded, the reviewers can 
      decrypt it.
      Due to HMAC, any modifications will be detected.
      The camera computes a MAC (all \(t_j\)) for every \(N\) blocks of 
      ciphertext.
      And \(R\) will know that the material was produced by \(C\).
      The camera then drops the video material to free space.
    }[fig:TransferCRHMAC]
  \flushright
  \begin{msc}
    [/msc/action width=0.4\linewidth]
    {Transfer data from \(C\) to \(R\) using HMAC}
      \declinst{cam}{Camera \(C\)}{\(\KCR\)}
      \declinst{rev}{Reviewers \(R\)}{\(\KCR\)}
      \mscaction[/msc/action width=0.55\linewidth]{%
        \begin{align*}
          c_i &= c_i' \oplus m_i \\
          t_j &= \MAC[\KMAC, t_{j-1}, c_{j\cdot N}, \ldots, c_{(j+1)\cdot N-1}]
        \end{align*}
      }{cam}
      \nextlevel[6]
      \mess{I'm camera \(C\).}{cam}{rev}
      \nextlevel[2]
      \mess{\(c = c_0, \ldots, c_{N-1}, t_1, \ldots, c_N, \ldots, c_{2\cdot 
      N-1}, t_2, \ldots\)}{cam}{rev}
      \nextlevel
      \mscaction[/msc/action width=10em]{\(m = \Dec[\KENC, c]\)}{rev}
      \mscaction[/msc/action width=8em]{Drop \(c\)}{cam}
      \nextlevel
  \end{msc}
  \end{sidecaption}
\end{figure}

\subsection{Consequences of the design}

Since \(t_i\) depends on \(t_{i-1}\), we will detect if someone would try to 
drop \(N\) blocks.
Or if someone would try to insert \(N\) blocks.
Or reorder them.
Or modify them.
We would detect exactly where the problem is and we would see that other parts 
are intact.

It would cause synchronization problems if someone would drop \emph{one} block.
Or insert one block.
(Or anything that is not a multiple of \(N\) blocks.)
However, we can test if someone has dropped or inserted a block, by trying the 
opposite.
It's not that efficient though, but then we could detect what is still usable 
and in which \(N\)-block that blocks are missing.


\section{Switching to digital signatures}

Now we want to replace HMAC with digital signatures.
